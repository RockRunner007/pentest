#!/usr/bin/env python3

# Imports
import argparse
import logging
import sys
import traceback
import re
import csv
import boto3
import botocore
from socket import inet_aton

# Configure logging
formatter = logging.Formatter('%(asctime)s\t[%(levelname)s]    %(message)s', '%Y-%m-%d %H:%M:%S')
handler = logging.StreamHandler(sys.stdout)
handler.setFormatter(formatter)
logger = logging.getLogger('ec2-ip')
logger.addHandler(handler)
default_output_name = 'artifacts/size_aws.csv'

# Main function
def main(args):
    # Variables
    logger.setLevel(logging.INFO)
    logging.getLogger('ec2-ip')
    regions = []
    static_count = 0
    csv_fieldnames = ['AccountId', 'Service', 'Region', 'ResourceType', 'Resource', 'IsPrivateIP', 'AssociatedDevice',
                      'IsStatic']

    # Configure boto3
    if args['profile']:
        boto3_session = boto3.Session(profile_name=args['profile'])
    elif args['access_key'] and not args['session_token']:
        boto3_session = boto3.Session(aws_access_key_id=args['access_key'],
                                      aws_secret_access_key=args['secret_key'])
    elif args['session_token']:
        boto3_session = boto3.Session(aws_access_key_id=args['access_key'],
                                      aws_secret_access_key=args['secret_key'],
                                      aws_session_token=args['session_token'])

    # Get caller identity
    logger.info('Making API calls as ' + str(get_caller_identity()))

    # Get all supported AWS regions
    if not args['region']:
        logger.info('Getting all supported AWS regions')
        client_ec2 = boto3.client('ec2')
        describe_regions = client_ec2.describe_regions()
        for region in describe_regions['Regions']:
            regions.append(region['RegionName'])
    else:
        regions = [args['region']]

    # Get all IPs for each region
    ec2_ips = get_all_ips(regions)

    # Get all elastic IPs for each region
    ec2_elastic_ips = get_all_elastic_ips(regions)

    # Determine if IPs are static
    logger.info('Processing results')
    for ip in ec2_ips:
        is_static = ip['Resource'] in ec2_elastic_ips
        ip['IsStatic'] = is_static
        if is_static:
            static_count += 1

    # Print stats
    logger.info(f'Found {len(ec2_ips)} EC2 IP addresses, {static_count} of which are static')

    # Configure output name if necessary
    if args['output'] == default_output_name:
        args['output'] = args['output'].replace('ACCOUNTID', get_caller_account_id())

    # Write results to file
    logger.info(f'Writing results to {args["output"]}')
    with open(args['output'], 'w', newline='', encoding='utf8', errors='ignore') as output:
        writer = csv.DictWriter(output, fieldnames=csv_fieldnames, quoting=csv.QUOTE_ALL, escapechar='\\')
        writer.writeheader()
        for resource in ec2_ips:
            writer.writerow(resource)
    logger.info(f'Results written to {args["output"]}')


# Get all EC2 IPs
def get_all_ips(regions):
    ec2_ips = []
    logger = logging.getLogger('ec2-ip')
    account_id = get_caller_account_id()
    for region in regions:
        logger.info(f'Retrieving EC2 IP addresses in {region}')
        try:
            client_ec2 = boto3.client('ec2', region_name=region)
            paginator_describe_network_interfaces = client_ec2.get_paginator('describe_network_interfaces')
            page_iterator_describe_network_interfaces = paginator_describe_network_interfaces.paginate()
            for page in page_iterator_describe_network_interfaces:
                for interface in page['NetworkInterfaces']:
                    try:
                        ips_raw = []
                        ips_dedup = []
                        identifier = ''
                        # Get and deduplicate IPs
                        ips_raw.append(interface['PrivateIpAddress'])
                        try:
                            ips_raw.append(interface['Association']['PublicIp'])
                        except KeyError:
                            pass
                        for entry in interface['PrivateIpAddresses']:
                            ips_raw.append(entry['PrivateIpAddress'])
                        for entry in interface['PrivateIpAddresses']:
                            try:
                                ips_raw.append(entry['Association']['PublicIp'])
                            except KeyError:
                                pass
                        for ip in set(ips_raw):
                            if ip not in ips_dedup:
                                ips_dedup.append(ip)
                        ips_dedup.sort(reverse=False, key=lambda ip_key: inet_aton(ip_key))
                        # Get attached ID
                        try:
                            identifier = interface['Attachment']['InstanceId']
                        except KeyError:
                            pass
                        try:
                            if interface['Attachment']['InstanceOwnerId'] != account_id:
                                identifier = interface['Attachment']['InstanceOwnerId']
                        except KeyError:
                            pass
                        # Create object
                        for ip in ips_dedup:
                            temp_dict = {'AccountId': account_id,
                                         'Service': 'ec2',
                                         'Region': region,
                                         'ResourceType': 'EC2 IP Address',
                                         'Resource': ip,
                                         'IsPrivateIP': is_ip_private(str(ip)),
                                         'AssociatedDevice': identifier
                                         }
                            ec2_ips.append(temp_dict)
                    except Exception as error:
                        error_traceback = str(traceback.format_exc())
                        logger.error('Uncaught error occurred: ' + str(error))
                        logger.debug(error_traceback)
        except botocore.exceptions.ClientError as error:
            logger.error('AWS API Error (' + str(error.response['Error']['Code']) + '): ' + str(error))
            logger.debug(str(traceback.format_exc()))
        except Exception as error:
            error_traceback = str(traceback.format_exc())
            logger.error('Uncaught error occurred: ' + str(error))
            logger.debug(error_traceback)
    return ec2_ips


# Get all elastic (static) IPs
def get_all_elastic_ips(regions):
    ec2_elastic_ips = []
    logger = logging.getLogger('ec2-ip')
    for region in regions:
        logger.info(f'Retrieving EC2 elastic IP addresses in {region}')
        try:
            client_ec2 = boto3.client('ec2', region_name=region)
            describe_addresses = client_ec2.describe_addresses()
            for address_json in describe_addresses['Addresses']:
                ec2_elastic_ips.append(address_json['PublicIp'])
        except botocore.exceptions.ClientError as error:
            logger.error('AWS API Error (' + str(error.response['Error']['Code']) + '): ' + str(error))
            logger.debug(str(traceback.format_exc()))
        except Exception as error:
            error_traceback = str(traceback.format_exc())
            logger.error('Uncaught error occurred: ' + str(error))
            logger.debug(error_traceback)
    return ec2_elastic_ips


# Get caller identity
def get_caller_identity():
    client_sts = boto3.client('sts')
    identity = client_sts.get_caller_identity()
    calling_principal = str(identity['Arn'])
    return calling_principal


# Get caller account
def get_caller_account_id():
    client_sts = boto3.client('sts')
    identity = client_sts.get_caller_identity()
    account_id = str(identity['Account'])
    return account_id


# Determines if an IP address is private or public
def is_ip_private(ip_address):
    private = False
    private_regexes = ['^127.\d{1,3}.\d{1,3}.\d{1,3}$',
                       '^10.\d{1,3}.\d{1,3}.\d{1,3}$',
                       '^192.168.\d{1,3}.\d{1,3}$',
                       '^172.(1[6-9]|2[0-9]|3[0-1]).[0-9]{1,3}.[0-9]{1,3}$']
    for regex in private_regexes:
        if re.match(regex, ip_address):
            private = True
    return private


# Run from CLI
if __name__ == '__main__':
    # Parse arguments
    parser = argparse.ArgumentParser(description='Automatically get all EC2 IP addresses in an AWS account')
    arg_options = parser.add_argument_group('Authentication Options')
    arg_options.add_argument('--profile',
                             help='Named profile to use. Profile should be present in ~/.aws/credentials',
                             type=str)
    arg_options.add_argument('--access-key',
                             help='Access key to use. Also provide the secret key with --secret-key.',
                             type=str)
    arg_options.add_argument('--secret-key',
                             help='Secret key to use. Also provide the access key with --access-key.',
                             type=str)
    arg_options.add_argument('--session-token',
                             help='Session-token to use. Also provide the access key with --access-key and the secret '
                                  'key with --secret-key',
                             type=str)

    optional_args = parser.add_argument_group('Optional Options')
    optional_args.add_argument('--region',
                               help='Only enumerate IPs in the provided region instead of all regions',
                               type=str)
    optional_args.add_argument('--output',
                               help=f'File to write results to in CSV format, default={default_output_name}',
                               type=str,
                               default=default_output_name)

    raw_args = parser.parse_args()

    # Validate arguments
    if (raw_args.access_key and not raw_args.secret_key) or (not raw_args.access_key and raw_args.secret_key):
        parser.error('--access-key and --secret-key arguments must both be provided')
    if raw_args.session_token and not raw_args.access_key and not raw_args.secret_key:
        parser.error('--session-token requires --access-key and --secret-key arguments')
    if (raw_args.access_key and raw_args.secret_key) and raw_args.profile:
        parser.error('Cannot use --access-key/--secret-key and --profile at the same time')

    # Configure args
    args = raw_args.__dict__

    # Run
    main(args)
